三種排序（**Selection Sort、Bubble Sort、Insertion Sort**）雖然都是 **基礎的排序演算法**，但它們的 **概念、時間複雜度、實際效能** 都有些差異。

---

## 1️⃣ Selection Sort（選擇排序）

**原理：**

* 每一輪從「未排序區」選出最小（或最大）的元素，放到正確位置。
* 換句話說，就是「每輪挑一個最小值，放到前面」。

**特點：**

* 交換次數少（最多 n-1 次），但比較次數多（固定 n(n-1)/2）。
* 不管資料是否接近有序，效率都一樣。

**時間複雜度：**

* 最好情況：O(n²)
* 最壞情況：O(n²)
* 平均情況：O(n²)
* 空間複雜度：O(1)

---

## 2️⃣ Bubble Sort（氣泡排序）

**原理：**

* 相鄰元素兩兩比較，若順序錯誤就交換，像「冒泡」一樣把最大值推到最後。
* 每一輪確保最後的元素是正確的。

**特點：**

* 如果資料已經接近排序完成，效率會比較好（因為可以提早停止）。
* 交換次數可能比 Selection Sort 多。

**時間複雜度：**

* 最好情況：O(n)（如果檢查到一輪沒有交換，就可以結束）
* 最壞情況：O(n²)
* 平均情況：O(n²)
* 空間複雜度：O(1)

---

## 3️⃣ Insertion Sort（插入排序）

**原理：**

* 把當前元素插入到前面已經排好序的序列中。
* 就像打牌時整理手牌：抽到新牌 → 插到正確的位置。

**特點：**

* 適合「幾乎有序」的小型資料集，因為效率接近 O(n)。
* 稍微比 Bubble Sort、Selection Sort 更有效率。

**時間複雜度：**

* 最好情況：O(n)（已經幾乎排好序，只要比較不需交換）
* 最壞情況：O(n²)
* 平均情況：O(n²)
* 空間複雜度：O(1)

---

## ⚖️ 三者比較表

| 演算法                | 原理              | 最好    | 平均    | 最壞    | 空間   | 特點           |
| ------------------ | --------------- | ----- | ----- | ----- | ---- | ------------ |
| **Selection Sort** | 每次選最小/最大放前面     | O(n²) | O(n²) | O(n²) | O(1) | 交換少，但比較固定很多  |
| **Bubble Sort**    | 相鄰交換，把最大值「冒泡」到後 | O(n)  | O(n²) | O(n²) | O(1) | 若快排序好可提早結束   |
| **Insertion Sort** | 插入到前面已排序好的序列    | O(n)  | O(n²) | O(n²) | O(1) | 小資料集、近乎有序時最快 |

---

## 🎯 總結
* **小資料 / 幾乎有序**：Insertion Sort 最快
* **不管資料狀況都穩定耗時**：Selection Sort（但通常最慢）
* **希望有「提早結束」機會**：Bubble Sort
* 真正在實務上用的，通常是 **Merge Sort、Quick Sort、Heap Sort**，因為能做到 O(n log n)。

要不要我幫你用一個 **範例陣列**（例如 `[5, 3, 8, 4]`），把這三種排序的步驟逐一 trace 出來，讓你直觀比較它們的運作方式？
